{"version":3,"sources":["../../../src/execution/agent-executor.ts"],"sourcesContent":["/**\n * Agent Executor - Wrapper around agentic-flow execution engine\n * Integrates agentic-flow agents with claude-flow hooks and coordination\n */\n\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport path from 'path';\nimport fs from 'fs-extra';\n\nconst execAsync = promisify(exec);\n\nexport interface AgentExecutionOptions {\n  agent: string;\n  task: string;\n  provider?: 'anthropic' | 'openrouter' | 'onnx' | 'gemini';\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  outputFormat?: 'text' | 'json' | 'markdown';\n  stream?: boolean;\n  verbose?: boolean;\n  retryOnError?: boolean;\n  timeout?: number;\n\n  // ReasoningBank memory options\n  enableMemory?: boolean;           // Enable ReasoningBank learning\n  memoryDatabase?: string;          // Path to .swarm/memory.db\n  memoryRetrievalK?: number;        // Top-k memories to retrieve (default: 3)\n  memoryLearning?: boolean;         // Enable post-task learning (default: true)\n  memoryDomain?: string;            // Domain filter for memories\n  memoryMinConfidence?: number;     // Minimum confidence threshold (default: 0.5)\n  memoryTaskId?: string;            // Unique task ID for tracking\n}\n\nexport interface AgentExecutionResult {\n  success: boolean;\n  output: string;\n  error?: string;\n  provider: string;\n  model: string;\n  tokens?: number;\n  cost?: number;\n  duration: number;\n  agent: string;\n  task: string;\n\n  // ReasoningBank metrics\n  memoryEnabled?: boolean;\n  memoriesRetrieved?: number;\n  memoriesUsed?: string[];          // IDs of memories applied\n  memoryLearned?: boolean;          // Whether new memories were created\n  memoryVerdict?: 'success' | 'failure';\n  memoryConfidence?: number;\n  newMemoryIds?: string[];          // IDs of newly created memories\n}\n\nexport class AgentExecutor {\n  private readonly agenticFlowPath: string;\n  private readonly hooksManager: any;\n  private memoryEnabled: boolean = false;\n  private memoryDatabase: string = '.swarm/memory.db';\n\n  constructor(hooksManager?: any) {\n    this.hooksManager = hooksManager;\n    // Agentic-flow is installed as npm dependency\n    this.agenticFlowPath = 'npx agentic-flow';\n  }\n\n  /**\n   * Initialize ReasoningBank database\n   */\n  async initializeMemory(dbPath?: string): Promise<void> {\n    const db = dbPath || this.memoryDatabase;\n\n    try {\n      const { stdout } = await execAsync(\n        `${this.agenticFlowPath} reasoningbank init`\n      );\n\n      this.memoryEnabled = true;\n      this.memoryDatabase = db;\n      console.log('✅ ReasoningBank initialized:', db);\n    } catch (error: any) {\n      console.error('Failed to initialize ReasoningBank:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory statistics\n   */\n  async getMemoryStats(): Promise<any> {\n    if (!this.memoryEnabled) {\n      return { enabled: false, totalMemories: 0 };\n    }\n\n    try {\n      const { stdout } = await execAsync(\n        `${this.agenticFlowPath} reasoningbank status`\n      );\n      return { enabled: true, output: stdout };\n    } catch (error: any) {\n      return { enabled: true, error: error.message };\n    }\n  }\n\n  /**\n   * Run memory consolidation (dedup + prune)\n   */\n  async consolidateMemories(): Promise<void> {\n    if (!this.memoryEnabled) return;\n\n    try {\n      await execAsync(\n        `${this.agenticFlowPath} reasoningbank consolidate`\n      );\n      console.log('✅ Memory consolidation complete');\n    } catch (error: any) {\n      console.warn('Consolidation failed:', error.message);\n    }\n  }\n\n  /**\n   * Execute an agent with agentic-flow\n   */\n  async execute(options: AgentExecutionOptions): Promise<AgentExecutionResult> {\n    const startTime = Date.now();\n    const taskId = options.memoryTaskId || `task-${Date.now()}`;\n\n    try {\n      // Initialize memory if requested\n      if (options.enableMemory && !this.memoryEnabled) {\n        try {\n          await this.initializeMemory(options.memoryDatabase);\n        } catch (error) {\n          console.warn('Memory initialization failed, continuing without memory');\n        }\n      }\n\n      // Trigger pre-execution hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('pre-agent-execute', {\n          agent: options.agent,\n          task: options.task,\n          provider: options.provider || 'anthropic',\n          timestamp: Date.now(),\n          memoryEnabled: this.memoryEnabled || options.enableMemory,\n        });\n      }\n\n      // Build agentic-flow command\n      const command = this.buildCommand(options);\n\n      // Execute command\n      const { stdout, stderr } = await execAsync(command, {\n        timeout: options.timeout || 300000, // 5 minutes default\n        maxBuffer: 10 * 1024 * 1024, // 10MB buffer,\n      });\n\n      const duration = Date.now() - startTime;\n\n      // Parse output\n      const result: AgentExecutionResult = {\n        success: true,\n        output: stdout,\n        provider: options.provider || 'anthropic',\n        model: options.model || 'default',\n        duration,\n        agent: options.agent,\n        task: options.task,\n        memoryEnabled: this.memoryEnabled || options.enableMemory || false,\n      };\n\n      // Trigger post-execution hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('post-agent-execute', {\n          agent: options.agent,\n          task: options.task,\n          result,\n          success: true,\n        });\n      }\n\n      return result;\n    } catch (error: any) {\n      const duration = Date.now() - startTime;\n\n      const result: AgentExecutionResult = {\n        success: false,\n        output: '',\n        error: error.message,\n        provider: options.provider || 'anthropic',\n        model: options.model || 'default',\n        duration,\n        agent: options.agent,\n        task: options.task,\n        memoryEnabled: this.memoryEnabled || options.enableMemory || false,\n      };\n\n      // Trigger error hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('agent-execute-error', {\n          agent: options.agent,\n          task: options.task,\n          error: error.message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * List available agents from agentic-flow\n   */\n  async listAgents(source?: 'all' | 'package' | 'local'): Promise<string[]> {\n    try {\n      // Agentic-flow uses 'agent list' command\n      const command = source\n        ? `${this.agenticFlowPath} agent list --filter ${source}`\n        : `${this.agenticFlowPath} agent list`;\n\n      const { stdout } = await execAsync(command);\n\n      // Parse agent list from output\n      const agents = stdout\n        .split('\\n')\n        .filter(line => line.trim())\n        .map(line => line.trim());\n\n      return agents;\n    } catch (error: any) {\n      console.error('Failed to list agents:', error.message);\n      return [];\n    }\n  }\n\n  /**\n   * Get agent information\n   */\n  async getAgentInfo(agentName: string): Promise<any> {\n    try {\n      // Agentic-flow uses 'agent info' command\n      const command = `${this.agenticFlowPath} agent info ${agentName}`;\n      const { stdout } = await execAsync(command);\n\n      // Try to parse as JSON if it looks like JSON\n      if (stdout.trim().startsWith('{')) {\n        return JSON.parse(stdout);\n      }\n\n      // Otherwise return as plain text\n      return { name: agentName, description: stdout };\n    } catch (error: any) {\n      console.error('Failed to get agent info:', error.message);\n      return null;\n    }\n  }\n\n  /**\n   * Build agentic-flow command from options\n   */\n  private buildCommand(options: AgentExecutionOptions): string {\n    const parts = [this.agenticFlowPath];\n\n    // Agentic-flow uses --agent flag directly (no 'execute' subcommand)\n    parts.push('--agent', options.agent);\n    parts.push('--task', `\"${options.task.replace(/\"/g, '\\\\\"')}\"`);\n\n    if (options.provider) {\n      parts.push('--provider', options.provider);\n    }\n\n    if (options.model) {\n      parts.push('--model', options.model);\n    }\n\n    if (options.temperature !== undefined) {\n      parts.push('--temperature', options.temperature.toString());\n    }\n\n    if (options.maxTokens) {\n      parts.push('--max-tokens', options.maxTokens.toString());\n    }\n\n    if (options.outputFormat) {\n      parts.push('--output-format', options.outputFormat);\n    }\n\n    if (options.stream) {\n      parts.push('--stream');\n    }\n\n    if (options.verbose) {\n      parts.push('--verbose');\n    }\n\n    // Note: agentic-flow doesn't have a --retry flag\n    // Retry logic should be handled by AgentExecutor if needed\n\n    return parts.join(' ');\n  }\n}\n\nexport default AgentExecutor;\n"],"names":["exec","promisify","execAsync","AgentExecutor","agenticFlowPath","hooksManager","memoryEnabled","memoryDatabase","initializeMemory","dbPath","db","stdout","console","log","error","message","getMemoryStats","enabled","totalMemories","output","consolidateMemories","warn","execute","options","startTime","Date","now","taskId","memoryTaskId","enableMemory","trigger","agent","task","provider","timestamp","command","buildCommand","stderr","timeout","maxBuffer","duration","result","success","model","listAgents","source","agents","split","filter","line","trim","map","getAgentInfo","agentName","startsWith","JSON","parse","name","description","parts","push","replace","temperature","undefined","toString","maxTokens","outputFormat","stream","verbose","join"],"mappings":"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"}